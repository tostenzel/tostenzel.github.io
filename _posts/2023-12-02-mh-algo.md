---
layout: distill
title: The Metropolis Hastings Algorithm
date: 2023-12-01
description: The MH Algorithm is often used for parameter estimation. The main building block are Markov chains, an important general concept.
#categories: deep-learning
tags: markov-chains
giscus_comments: true
related_posts: true
bibliography: references.bib

authors:
  - name: Tobias Stenzel
    url: "https://www.tobiasstenzel.com"
    affiliations:
      name: N/A

# Optionally, you can add a table of contents to your post.
# NOTES:
#   - make sure that TOC names match the actual section names
#     for hyperlinks within the post to work correctly.
#   - we may want to automate TOC generation in the future using
#     jekyll-toc plugin (https://github.com/toshimaru/jekyll-toc).
toc:
  - name: lol


---



# Introduction

The Metropolis-Hastings (MH) algorithm is a method for sampling data points from a probability distribution from which direct sampling is difficult. It places among the top 10 algorithms with the greatest influence on science and engineering in the 20th century [@beichl2000metropolis]. The MH algorithm belongs to the class of Markov chain Monte Carlo (MCMC) methods. In my explanation I assume prior knowledge on Monte Carlo sampling. However, I will describe the basics of Markov Chains. First, I give a high-level explanation of how to use the MH algorithm for estimating model paramters. Second, I present the basics of Markov chains. Third, I derive the algorithm and show why it works.

# Use Case: Model Estimation

One main application for the MH algorithm (@Chib1995) is Bayesian inference (See @Lambert2018, Chapters 4 - 7.). Specifically, we want to estimate parameters $\Theta$ of some probabilistic model $f$. We have only limited prior knowledge of the distribution of $\Theta$, for example, about its domain. We use this knowledge to define prior distributions $p(\Theta)$. And we have a likelihood sample of $f$ given the unknown parameters $\Theta$, namely $p(y\mid\Theta)$. This is our PSD data $y_{ikt}$. We want to use both, our prior knowledge and our data, to obtain the posterior distribution $p(\Theta \mid y)$ in [1](#eq:bayes). In this align, posterior and likelihood are scaled by $\frac{1}{p(y)}$. Without closed-form distributions for prior and likelihood, $p(y)$ is usually unknown. The posterior is proportional to the product of likelihood and prior. However, without the scaling factor it is not a probability distribution.

$$\begin{align}
\label{eq:bayes}
p(\Theta \mid y) = \frac{\mathcal{L}(y \mid \Theta)p(\Theta)}{p(y)} \propto \mathcal{L}(y \mid \Theta)p(\Theta)
\end{align}$$

An important insight is that our parameter vector $\Theta$ does not only include parameters defined as distributional means, for instance $\theta$, but also standard deviations like $\sigma_{\theta}$. If our problem would not include these variation parameters, a simpler option would be to solve $\mathcal{L}(y \mid \Theta)p(\Theta)$ directly with the usual optimization algorithms. The algorithm would propose new values of $\Theta$, evaluate its prior probability and the likelihood of the data given $\Theta$ until convergence, and return the posterior mode. The mode is also called the maximum a posteriori probability (MAP) estimate. Yet, since we need to estimate standard deviations, we have to generate the whole parameter distributions to compute mean and variation. To this end, we use a Markov chain Monte Carlo (MCMC) method, namely the Metropolis Hastings (MH) algorithm.

Markov chains are stochastic processes that define distributions dependent on the values from the previous period only. The MH algorithm uses Markov chains to sample candidate parameters $$\Theta_i^{*}$$ depending on $$\Theta_{i-1}$$. For each candidate $$\Theta_i^{*}$$, the algorithm uses the unscaled posterior $$\mathcal{L}(y \mid \Theta_i)p(\Theta_i)$$ and compares it with the posterior of $$\Theta_{i-1}$$ to accept or reject new candidates (not requiring constant $$p(y)$$). Comparing relative posterior probabilities and using this comparison for the selection of new candidates proportional to their relative probability allows us to sample from the posterior probability distribution without knowing $$p(y)$$ and to compute its mean and variation. The algorithm thus explores the domain proportionally to the posterior probability after a number of initial iterations. Besides the model specification, using the MH algorithm requires among others the following choices (Note that there are much more potential choices depending on the MH variant and the specific setup and context.): the prior distribution(s) $$p(\Theta)$$, the proposal distribution $$g(y_i, y_{i-1})$$, and the number initial parameter draws to drop from the whole MCMC sample, i.e. the length of the warmup period. Usually one initializes multiple Markov chains at once and combines the samples less the warmup afterwards. This practice decreases the dependency on the starting value. Hence, the number of chains is an additional hyperparameter. I include a more technical explanation of the MH algorithm with a more general notation in the Appendix.

# Markov Chains

A Markov chain $$(X_t)_{t \in \mathbb{N}}$$ is a stochastic process (over time) with the property that the probability of the realization in the next period depends solely on the realization in the current state and not the complete history. This is called the Markov property. Because Markov chains with a countable, or discrete, state space are much more accessible than their continuous variant, in this chapter we will look at the discrete case. Formally, the Markov property writes:

$$\begin{align}
P(X_{t+1}  \mid X_{t}, X_{t-1}, ..., X_{0}) = P(X_{t+1}  \mid X_{t}).
\end{align}$$

Under some conditions, the stochastic process described by a Markov chain converges to a time-invariant probability distribution, i.e., $$P(X_{t+k}  \mid X_{t+k-1}) = P(X_{t}  \mid X_{t-1}), \forall k>0$$. The crucial step for understanding the MH algorithm is to see how it samples a Markov chain that is certain to converge to a stable posterior distribution. Before exploring how the algorithm achieves this result, however, it is necessary to understand the required conditions conceptually. To this end, we will use the example depicted by the following graph in Figure 6 that shows the intertemporal transition probabilities between three states representing random events.

![Transition Graph for Markov Chain with 3 states.](#fig:ex1)

This transition graph can be summarized by the $$n \times n$$ transition matrix T where each element $$(i,j)$$ represents the probability of moving from state $$i$$ in period $$t$$ to state $$k$$ in period $$t+1$$, and where $$n$$ represents the number of states, i.e., $$T_{i,j} = P(X_{t+1}=j  \mid  X_t = i)$$. For our example, we have:

$$\begin{align}
T=
\begin{pmatrix}
0 & 1 & 0\\
0 & 0.1 & 0.9\\
0.6 & 0.4 & 0
\end{pmatrix}
.
\end{align}$$


### Limit Distribution

As touched upon in the previous subsection, an interesting question can be what the probabilities of each state $$j \in \{1, ..., s\}$$ are after a finite number or infinitely many steps. For this purpose let $$\pi_t (j) = P(X_t = j)$$ denote the probability of being in state $$j$$ in period $$t$$. Of course, the probabilities in $$t>0$$ depend on the probabilities for the initial state $$\pi_0$$. We can use the law of total probability to calculate the probability of each state for the next period $$t=1$$ by:

$$\begin{align}
P(X_1 = j) = \sum_{i=1}^{3} P(X_1 = j  \mid  X_0 = i) \pi_0(i).
\end{align}$$

I.e., to compute the probability of being in state $$j$$ in $$t=1$$, for each initial state $$i$$, we multiply its probability $$\pi_0(i)$$ by the probability of moving from $$i$$ to state $$j$$. This is equivalent to $$\pi_1 = \pi_0 T$$ in vector notation. Further, we can compute the distributions in an arbitrary future period by repeating the matrix multiplication, e.g., $$\pi_2 = \pi_0 T T$$, or in general, $$\pi_t = \pi_0 T^t$$.

Now we are ready to define the limit distribution that describes the probability distribution after infinitely many periods by:

$$\begin{align}
\pi_{\infty} = \lim_{t \rightarrow \infty} \pi_t = \lim_{t \rightarrow \infty} \pi_0 T^t.
\end{align}$$

We can further ask two additional important questions. First, does a limit distribution exist? And second, is it unique, or in other words, do we have the same limit distribution independent from the realization of the initial state $$X_0$$? In our example, there does not only exist a limit distribution with $$\pi_{\infty} = (0.2, 0.4, 0.4)$$, it is even unique regardless of the start distribution $$\pi_0$$. This means that independent of the start state, the probability of each state converges to the same number. For the context of the MH algorithm, this is an important property because we always want to compute the same estimates for our parameters $$\theta$$, regardless of the starting values of our simulation. In the next section, we introduce and simplify conditions that guarantee a unique limit distribution.

### Irreducibility, Periodicity, and Stationarity

**Definition:**
A Markov chain is called *irreducible* if each state is reachable from any other state in a finite number of steps.

Figure 7 shows a Markov chain represented by a bipartite graph. This graph is composed of two times the graph in Figure 6. Obviously, this chain is not irreducible because the initial state impacts all future distributions. More precisely, starting in one subgraph sets the probability of reaching states in the other subgraph to zero. We see that a Markov Chain is only irreducible if there is at least an indirect link between every pair of states. We also observe that if the Markov Chain is not irreducible there can be no limit distribution.

![Transition Graph for Irreducible Markov Chain.](#fig:ex2)

**Definition:**
A state $$i$$ has a period $$k$$ if the greatest common denominator of possible revisits is $$k$$. A Markov chain is *aperiodic* if the period of all its states is 1.

Consider the five-state Markov chain in Figure 8 as an illustration for the above definition and suppose we start in state 1. Observe that, independent of the random draw for the next period, we will arrive again in state 1 after two or four steps. Therefore, state 1 has a period of 2. If a state is revisited in random rather than a fixed time period then the state has a period of 1. This is automatically the case if a state has a strictly positive edge with itself.

![Markov Chain with 2-periodic State 1](#fig:ex3)

**Definition:**
$$\pi^{*}$$ is the *stationary distribution* of a Markov Chain with Transition matrix in align (11) T if $$\pi^{*} = \pi^{*} T$$ and $$\pi^{*}$$ is a probability vector.

Verbally, this means that the probability distribution $$\pi^{*}$$ does not change anymore over time. If $$\pi^{*}$$ is also unique, then $$\pi^{*}$$, the limit distribution that we are looking for in section 7.3.1, i.e., $$\pi^{*}=\pi_{\infty}$$.

These three definitions are enough to understand the next fundamental theorem.

### The Fundamental Theorem of Markov Chains

This theorem formally defines the condition when a Markov Chain converges to a unique distribution, i.e. the limit distribution.

**Theorem (Fundamental Theorem of Markov Chains):**
If a Markov chain is irreducible and aperiodic (called ergodic) then it has a stationary distribution $$\pi^{*}$$ that is unique ($$\lim_{t \rightarrow \infty} P(X_t = i) = \pi_i^{*}, \forall i$$).

Therefore, if we want to construct a stable distribution $$P(X)$$ via Markov chains, we need to ensure that it is irreducible and aperiodic with stationary distribution $$\pi^{*}=P(X)$$. In the next subsection, we substitute the stationarity condition by a stronger one before we finally derive the MH algorithm.

### Reversibility

**Definition:**
A Markov chain is *reversible* if there is a probability distribution $$\pi$$ over its states such that $$\pi(i) T_{ij} = \pi(j)T_{j,i}, \forall i,j$$ (reversibility condition).

**Theorem:**
A sufficient condition for distribution $$\pi^{*}$$ to be a stationary distribution of a Markov chain with transition matrix T is that it fulfills the reversibility condition.

**Proof:**
$$\sum_i \pi(i) T_{i,j} = \sum_i \pi(j) T_{j,i} = \pi(j) \sum_i  T_{j,i} = \pi(j) \implies \pi T = \pi$$

Reversibility is a stronger condition than stationarity because it requires that the probability flux from $$i$$ to $$j$$ is equal to the one from $$j$$ to $$i$$ for each possible pair of states. Recall that stationarity only requires that the probability flux to one state is equal on aggregate and not that it is symmetric between each pair of states over time. Therefore, if we want to achieve a stationary distribution it is enough to ensure that it is reversible.

## The Algorithm

Recall that we want to generate a sample of a desired distribution $$P(X)$$. For this purpose, we use a Markov process that is uniquely defined by its transition probabilities $$P(X_{t+1} \mid X)$$ with a limit distribution $$\pi$$ so that $$\pi=P(X)$$. As explained in the previous section, a Markov process has a limit distribution if each transition $$X_t \rightarrow X_{t+1}$$ is reversible and if the stationary distribution $$\pi$$ is ergodic. With the MH algorithm, we construct such a Markov process with a stationary distribution $$\pi=P(X)$$. The derivation starts with another way of writing reversibility^[We simplify our notation by using $$x'$$ and $$x$$ instead of $$X_{t+1}$$ and $$X_t$$.]:

\begin{align}
P(x' \mid x)P(x) = P(x \mid x')P(x') \iff \frac{P(x' \mid x)}{P(x \mid x')} = \frac{P(x')}{P(x)}
(\#eq:trans)
\end{align}

The main idea is to separate the transition $$P(x' \mid x)$$ into two steps: the proposal step and the acceptance-or-rejection step. Let $$g(x')$$ be the proposal distribution, i.e., the conditional probability of proposing state $$x'$$ given $$x$$. And let $$A(x' \mid x)$$ be the probability of accepting the proposed state $$X'$$. Formally, we have $$P(x' \mid x)=g(x' \mid x) A(x' \mid x')$$. Inserting this into align \@ref(eq:trans) gives:

\begin{align}
\frac{P(x')}{P(x)} = \frac{g(x' \mid x)A(x',x)}{g(x \mid x')A(x',x)} \iff \frac{A(x',x)}{A(x,x')} = \frac{P(x')}{P(x)}\frac{g(x \mid x')}{g(x' \mid x)}.
(\#eq:two-steps)
\end{align}

The following choice, termed the Metropolis choice, is commonly used as an acceptance ratio for sampling $$x'$$ from $$P(x')$$ that fulfills the above reversibility condition:

\begin{align}
A(x',x) = \text{min}\left( 1, \frac{P(x')}{P(x)}\frac{g(x \mid x')}{g(x' \mid x)} \right)
(\#eq:Metropolis-choice)
\end{align}

Note that the minimizer in $$A(x',x)$$ enforces that the probability is smaller/equal 1. The MH algorithm writes as follows:

### The Algorithm

$$\begin{algorithm}[H]
\caption{Metropolis-Hastings algorithm}
\begin{algorithmic}
\State {Initialize $$X_0$$}

        \For{$$t \gets 0$$ to $$T-1$$} 
          \State {Draw $$u \sim \mathcal{U}_{[0,1]}$$}
          \State {Draw candidate $$X^{*} \sim P(X^{*} \mid X_{t-1})$$}
          \If{$$u < \text{min}\{1, \frac{p(X^{*})g(X_t \mid X^{*})}{p(X_t)g(X^{*} \mid X_t)}\}$$} 
              \State $$X_{t+1} \gets X^{*}$$
          \Else
              \State $$X_{t+1} \gets X_t$$
\EndIf 
        \EndFor   
\end{algorithmic}
\end{algorithm}$$

Obviously, the construction of the acceptance ratio ensures reversibility. Ergodicity is ensured by the random nature with which we accept proposed states: First, the chain is irreducible because each state is reachable from any other state with positive probability at every single step. Second, for each state $$x$$, $$P(x'=x)$$ is always positive, and therefore the Markov chain is aperiodic.

In a general setting, the choice for transition distribution $$g(x' \mid x)$$ and the number of iterations until the limit distribution is reached are unclear. These two choices are the hyperparameters of the MH algorithm. In the Bayesian inference application in the article series starting from @Claassen2019estimating, additional important choices are the prior distribution $$p(\theta)$$ and the model choice $$f$$.